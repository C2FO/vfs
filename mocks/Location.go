// Code generated by mockery v2.46.3. DO NOT EDIT.

package mocks

import (
	options "github.com/c2fo/vfs/v6/options"
	mock "github.com/stretchr/testify/mock"

	regexp "regexp"

	vfs "github.com/c2fo/vfs/v6"
)

// Location is an autogenerated mock type for the Location type
type Location struct {
	mock.Mock
}

type Location_Expecter struct {
	mock *mock.Mock
}

func (_m *Location) EXPECT() *Location_Expecter {
	return &Location_Expecter{mock: &_m.Mock}
}

// ChangeDir provides a mock function with given fields: relLocPath
func (_m *Location) ChangeDir(relLocPath string) error {
	ret := _m.Called(relLocPath)

	if len(ret) == 0 {
		panic("no return value specified for ChangeDir")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(relLocPath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Location_ChangeDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChangeDir'
type Location_ChangeDir_Call struct {
	*mock.Call
}

// ChangeDir is a helper method to define mock.On call
//   - relLocPath string
func (_e *Location_Expecter) ChangeDir(relLocPath interface{}) *Location_ChangeDir_Call {
	return &Location_ChangeDir_Call{Call: _e.mock.On("ChangeDir", relLocPath)}
}

func (_c *Location_ChangeDir_Call) Run(run func(relLocPath string)) *Location_ChangeDir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Location_ChangeDir_Call) Return(_a0 error) *Location_ChangeDir_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Location_ChangeDir_Call) RunAndReturn(run func(string) error) *Location_ChangeDir_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteFile provides a mock function with given fields: relFilePath, opts
func (_m *Location) DeleteFile(relFilePath string, opts ...options.DeleteOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, relFilePath)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFile")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...options.DeleteOption) error); ok {
		r0 = rf(relFilePath, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Location_DeleteFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteFile'
type Location_DeleteFile_Call struct {
	*mock.Call
}

// DeleteFile is a helper method to define mock.On call
//   - relFilePath string
//   - opts ...options.DeleteOption
func (_e *Location_Expecter) DeleteFile(relFilePath interface{}, opts ...interface{}) *Location_DeleteFile_Call {
	return &Location_DeleteFile_Call{Call: _e.mock.On("DeleteFile",
		append([]interface{}{relFilePath}, opts...)...)}
}

func (_c *Location_DeleteFile_Call) Run(run func(relFilePath string, opts ...options.DeleteOption)) *Location_DeleteFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]options.DeleteOption, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(options.DeleteOption)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Location_DeleteFile_Call) Return(_a0 error) *Location_DeleteFile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Location_DeleteFile_Call) RunAndReturn(run func(string, ...options.DeleteOption) error) *Location_DeleteFile_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function with given fields:
func (_m *Location) Exists() (bool, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func() (bool, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Location_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type Location_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
func (_e *Location_Expecter) Exists() *Location_Exists_Call {
	return &Location_Exists_Call{Call: _e.mock.On("Exists")}
}

func (_c *Location_Exists_Call) Run(run func()) *Location_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Location_Exists_Call) Return(_a0 bool, _a1 error) *Location_Exists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Location_Exists_Call) RunAndReturn(run func() (bool, error)) *Location_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// FileSystem provides a mock function with given fields:
func (_m *Location) FileSystem() vfs.FileSystem {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for FileSystem")
	}

	var r0 vfs.FileSystem
	if rf, ok := ret.Get(0).(func() vfs.FileSystem); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(vfs.FileSystem)
		}
	}

	return r0
}

// Location_FileSystem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FileSystem'
type Location_FileSystem_Call struct {
	*mock.Call
}

// FileSystem is a helper method to define mock.On call
func (_e *Location_Expecter) FileSystem() *Location_FileSystem_Call {
	return &Location_FileSystem_Call{Call: _e.mock.On("FileSystem")}
}

func (_c *Location_FileSystem_Call) Run(run func()) *Location_FileSystem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Location_FileSystem_Call) Return(_a0 vfs.FileSystem) *Location_FileSystem_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Location_FileSystem_Call) RunAndReturn(run func() vfs.FileSystem) *Location_FileSystem_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function with given fields:
func (_m *Location) List() ([]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Location_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type Location_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
func (_e *Location_Expecter) List() *Location_List_Call {
	return &Location_List_Call{Call: _e.mock.On("List")}
}

func (_c *Location_List_Call) Run(run func()) *Location_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Location_List_Call) Return(_a0 []string, _a1 error) *Location_List_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Location_List_Call) RunAndReturn(run func() ([]string, error)) *Location_List_Call {
	_c.Call.Return(run)
	return _c
}

// ListByPrefix provides a mock function with given fields: prefix
func (_m *Location) ListByPrefix(prefix string) ([]string, error) {
	ret := _m.Called(prefix)

	if len(ret) == 0 {
		panic("no return value specified for ListByPrefix")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(prefix)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(prefix)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(prefix)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Location_ListByPrefix_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListByPrefix'
type Location_ListByPrefix_Call struct {
	*mock.Call
}

// ListByPrefix is a helper method to define mock.On call
//   - prefix string
func (_e *Location_Expecter) ListByPrefix(prefix interface{}) *Location_ListByPrefix_Call {
	return &Location_ListByPrefix_Call{Call: _e.mock.On("ListByPrefix", prefix)}
}

func (_c *Location_ListByPrefix_Call) Run(run func(prefix string)) *Location_ListByPrefix_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Location_ListByPrefix_Call) Return(_a0 []string, _a1 error) *Location_ListByPrefix_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Location_ListByPrefix_Call) RunAndReturn(run func(string) ([]string, error)) *Location_ListByPrefix_Call {
	_c.Call.Return(run)
	return _c
}

// ListByRegex provides a mock function with given fields: regex
func (_m *Location) ListByRegex(regex *regexp.Regexp) ([]string, error) {
	ret := _m.Called(regex)

	if len(ret) == 0 {
		panic("no return value specified for ListByRegex")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(*regexp.Regexp) ([]string, error)); ok {
		return rf(regex)
	}
	if rf, ok := ret.Get(0).(func(*regexp.Regexp) []string); ok {
		r0 = rf(regex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(*regexp.Regexp) error); ok {
		r1 = rf(regex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Location_ListByRegex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListByRegex'
type Location_ListByRegex_Call struct {
	*mock.Call
}

// ListByRegex is a helper method to define mock.On call
//   - regex *regexp.Regexp
func (_e *Location_Expecter) ListByRegex(regex interface{}) *Location_ListByRegex_Call {
	return &Location_ListByRegex_Call{Call: _e.mock.On("ListByRegex", regex)}
}

func (_c *Location_ListByRegex_Call) Run(run func(regex *regexp.Regexp)) *Location_ListByRegex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*regexp.Regexp))
	})
	return _c
}

func (_c *Location_ListByRegex_Call) Return(_a0 []string, _a1 error) *Location_ListByRegex_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Location_ListByRegex_Call) RunAndReturn(run func(*regexp.Regexp) ([]string, error)) *Location_ListByRegex_Call {
	_c.Call.Return(run)
	return _c
}

// NewFile provides a mock function with given fields: relFilePath, opts
func (_m *Location) NewFile(relFilePath string, opts ...options.NewFileOption) (vfs.File, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, relFilePath)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NewFile")
	}

	var r0 vfs.File
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...options.NewFileOption) (vfs.File, error)); ok {
		return rf(relFilePath, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, ...options.NewFileOption) vfs.File); ok {
		r0 = rf(relFilePath, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(vfs.File)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...options.NewFileOption) error); ok {
		r1 = rf(relFilePath, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Location_NewFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewFile'
type Location_NewFile_Call struct {
	*mock.Call
}

// NewFile is a helper method to define mock.On call
//   - relFilePath string
//   - opts ...options.NewFileOption
func (_e *Location_Expecter) NewFile(relFilePath interface{}, opts ...interface{}) *Location_NewFile_Call {
	return &Location_NewFile_Call{Call: _e.mock.On("NewFile",
		append([]interface{}{relFilePath}, opts...)...)}
}

func (_c *Location_NewFile_Call) Run(run func(relFilePath string, opts ...options.NewFileOption)) *Location_NewFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]options.NewFileOption, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(options.NewFileOption)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Location_NewFile_Call) Return(_a0 vfs.File, _a1 error) *Location_NewFile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Location_NewFile_Call) RunAndReturn(run func(string, ...options.NewFileOption) (vfs.File, error)) *Location_NewFile_Call {
	_c.Call.Return(run)
	return _c
}

// NewLocation provides a mock function with given fields: relLocPath
func (_m *Location) NewLocation(relLocPath string) (vfs.Location, error) {
	ret := _m.Called(relLocPath)

	if len(ret) == 0 {
		panic("no return value specified for NewLocation")
	}

	var r0 vfs.Location
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (vfs.Location, error)); ok {
		return rf(relLocPath)
	}
	if rf, ok := ret.Get(0).(func(string) vfs.Location); ok {
		r0 = rf(relLocPath)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(vfs.Location)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(relLocPath)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Location_NewLocation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewLocation'
type Location_NewLocation_Call struct {
	*mock.Call
}

// NewLocation is a helper method to define mock.On call
//   - relLocPath string
func (_e *Location_Expecter) NewLocation(relLocPath interface{}) *Location_NewLocation_Call {
	return &Location_NewLocation_Call{Call: _e.mock.On("NewLocation", relLocPath)}
}

func (_c *Location_NewLocation_Call) Run(run func(relLocPath string)) *Location_NewLocation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Location_NewLocation_Call) Return(_a0 vfs.Location, _a1 error) *Location_NewLocation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Location_NewLocation_Call) RunAndReturn(run func(string) (vfs.Location, error)) *Location_NewLocation_Call {
	_c.Call.Return(run)
	return _c
}

// Path provides a mock function with given fields:
func (_m *Location) Path() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Path")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Location_Path_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Path'
type Location_Path_Call struct {
	*mock.Call
}

// Path is a helper method to define mock.On call
func (_e *Location_Expecter) Path() *Location_Path_Call {
	return &Location_Path_Call{Call: _e.mock.On("Path")}
}

func (_c *Location_Path_Call) Run(run func()) *Location_Path_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Location_Path_Call) Return(_a0 string) *Location_Path_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Location_Path_Call) RunAndReturn(run func() string) *Location_Path_Call {
	_c.Call.Return(run)
	return _c
}

// String provides a mock function with given fields:
func (_m *Location) String() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for String")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Location_String_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'String'
type Location_String_Call struct {
	*mock.Call
}

// String is a helper method to define mock.On call
func (_e *Location_Expecter) String() *Location_String_Call {
	return &Location_String_Call{Call: _e.mock.On("String")}
}

func (_c *Location_String_Call) Run(run func()) *Location_String_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Location_String_Call) Return(_a0 string) *Location_String_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Location_String_Call) RunAndReturn(run func() string) *Location_String_Call {
	_c.Call.Return(run)
	return _c
}

// URI provides a mock function with given fields:
func (_m *Location) URI() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for URI")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Location_URI_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'URI'
type Location_URI_Call struct {
	*mock.Call
}

// URI is a helper method to define mock.On call
func (_e *Location_Expecter) URI() *Location_URI_Call {
	return &Location_URI_Call{Call: _e.mock.On("URI")}
}

func (_c *Location_URI_Call) Run(run func()) *Location_URI_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Location_URI_Call) Return(_a0 string) *Location_URI_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Location_URI_Call) RunAndReturn(run func() string) *Location_URI_Call {
	_c.Call.Return(run)
	return _c
}

// Volume provides a mock function with given fields:
func (_m *Location) Volume() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Volume")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Location_Volume_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Volume'
type Location_Volume_Call struct {
	*mock.Call
}

// Volume is a helper method to define mock.On call
func (_e *Location_Expecter) Volume() *Location_Volume_Call {
	return &Location_Volume_Call{Call: _e.mock.On("Volume")}
}

func (_c *Location_Volume_Call) Run(run func()) *Location_Volume_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Location_Volume_Call) Return(_a0 string) *Location_Volume_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Location_Volume_Call) RunAndReturn(run func() string) *Location_Volume_Call {
	_c.Call.Return(run)
	return _c
}

// NewLocation creates a new instance of Location. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLocation(t interface {
	mock.TestingT
	Cleanup(func())
}) *Location {
	mock := &Location{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
