// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"regexp"

	"github.com/c2fo/vfs/v7"
	"github.com/c2fo/vfs/v7/options"
	"github.com/c2fo/vfs/v7/utils/authority"
	mock "github.com/stretchr/testify/mock"
)

// NewLocation creates a new instance of Location. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLocation(t interface {
	mock.TestingT
	Cleanup(func())
}) *Location {
	mock := &Location{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Location is an autogenerated mock type for the Location type
type Location struct {
	mock.Mock
}

type Location_Expecter struct {
	mock *mock.Mock
}

func (_m *Location) EXPECT() *Location_Expecter {
	return &Location_Expecter{mock: &_m.Mock}
}

// Authority provides a mock function for the type Location
func (_mock *Location) Authority() authority.Authority {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Authority")
	}

	var r0 authority.Authority
	if returnFunc, ok := ret.Get(0).(func() authority.Authority); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(authority.Authority)
	}
	return r0
}

// Location_Authority_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Authority'
type Location_Authority_Call struct {
	*mock.Call
}

// Authority is a helper method to define mock.On call
func (_e *Location_Expecter) Authority() *Location_Authority_Call {
	return &Location_Authority_Call{Call: _e.mock.On("Authority")}
}

func (_c *Location_Authority_Call) Run(run func()) *Location_Authority_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Location_Authority_Call) Return(authority1 authority.Authority) *Location_Authority_Call {
	_c.Call.Return(authority1)
	return _c
}

func (_c *Location_Authority_Call) RunAndReturn(run func() authority.Authority) *Location_Authority_Call {
	_c.Call.Return(run)
	return _c
}

// ChangeDir provides a mock function for the type Location
func (_mock *Location) ChangeDir(relLocPath string) error {
	ret := _mock.Called(relLocPath)

	if len(ret) == 0 {
		panic("no return value specified for ChangeDir")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string) error); ok {
		r0 = returnFunc(relLocPath)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Location_ChangeDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChangeDir'
type Location_ChangeDir_Call struct {
	*mock.Call
}

// ChangeDir is a helper method to define mock.On call
//   - relLocPath string
func (_e *Location_Expecter) ChangeDir(relLocPath interface{}) *Location_ChangeDir_Call {
	return &Location_ChangeDir_Call{Call: _e.mock.On("ChangeDir", relLocPath)}
}

func (_c *Location_ChangeDir_Call) Run(run func(relLocPath string)) *Location_ChangeDir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Location_ChangeDir_Call) Return(err error) *Location_ChangeDir_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Location_ChangeDir_Call) RunAndReturn(run func(relLocPath string) error) *Location_ChangeDir_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteFile provides a mock function for the type Location
func (_mock *Location) DeleteFile(relFilePath string, opts ...options.DeleteOption) error {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(relFilePath, opts)
	} else {
		tmpRet = _mock.Called(relFilePath)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteFile")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, ...options.DeleteOption) error); ok {
		r0 = returnFunc(relFilePath, opts...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Location_DeleteFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteFile'
type Location_DeleteFile_Call struct {
	*mock.Call
}

// DeleteFile is a helper method to define mock.On call
//   - relFilePath string
//   - opts ...options.DeleteOption
func (_e *Location_Expecter) DeleteFile(relFilePath interface{}, opts ...interface{}) *Location_DeleteFile_Call {
	return &Location_DeleteFile_Call{Call: _e.mock.On("DeleteFile",
		append([]interface{}{relFilePath}, opts...)...)}
}

func (_c *Location_DeleteFile_Call) Run(run func(relFilePath string, opts ...options.DeleteOption)) *Location_DeleteFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []options.DeleteOption
		var variadicArgs []options.DeleteOption
		if len(args) > 1 {
			variadicArgs = args[1].([]options.DeleteOption)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *Location_DeleteFile_Call) Return(err error) *Location_DeleteFile_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Location_DeleteFile_Call) RunAndReturn(run func(relFilePath string, opts ...options.DeleteOption) error) *Location_DeleteFile_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type Location
func (_mock *Location) Exists() (bool, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (bool, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Location_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type Location_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
func (_e *Location_Expecter) Exists() *Location_Exists_Call {
	return &Location_Exists_Call{Call: _e.mock.On("Exists")}
}

func (_c *Location_Exists_Call) Run(run func()) *Location_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Location_Exists_Call) Return(b bool, err error) *Location_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *Location_Exists_Call) RunAndReturn(run func() (bool, error)) *Location_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// FileSystem provides a mock function for the type Location
func (_mock *Location) FileSystem() vfs.FileSystem {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for FileSystem")
	}

	var r0 vfs.FileSystem
	if returnFunc, ok := ret.Get(0).(func() vfs.FileSystem); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(vfs.FileSystem)
		}
	}
	return r0
}

// Location_FileSystem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FileSystem'
type Location_FileSystem_Call struct {
	*mock.Call
}

// FileSystem is a helper method to define mock.On call
func (_e *Location_Expecter) FileSystem() *Location_FileSystem_Call {
	return &Location_FileSystem_Call{Call: _e.mock.On("FileSystem")}
}

func (_c *Location_FileSystem_Call) Run(run func()) *Location_FileSystem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Location_FileSystem_Call) Return(fileSystem vfs.FileSystem) *Location_FileSystem_Call {
	_c.Call.Return(fileSystem)
	return _c
}

func (_c *Location_FileSystem_Call) RunAndReturn(run func() vfs.FileSystem) *Location_FileSystem_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type Location
func (_mock *Location) List() ([]string, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]string, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []string); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Location_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type Location_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
func (_e *Location_Expecter) List() *Location_List_Call {
	return &Location_List_Call{Call: _e.mock.On("List")}
}

func (_c *Location_List_Call) Run(run func()) *Location_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Location_List_Call) Return(strings []string, err error) *Location_List_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *Location_List_Call) RunAndReturn(run func() ([]string, error)) *Location_List_Call {
	_c.Call.Return(run)
	return _c
}

// ListByPrefix provides a mock function for the type Location
func (_mock *Location) ListByPrefix(prefix string) ([]string, error) {
	ret := _mock.Called(prefix)

	if len(ret) == 0 {
		panic("no return value specified for ListByPrefix")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return returnFunc(prefix)
	}
	if returnFunc, ok := ret.Get(0).(func(string) []string); ok {
		r0 = returnFunc(prefix)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(prefix)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Location_ListByPrefix_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListByPrefix'
type Location_ListByPrefix_Call struct {
	*mock.Call
}

// ListByPrefix is a helper method to define mock.On call
//   - prefix string
func (_e *Location_Expecter) ListByPrefix(prefix interface{}) *Location_ListByPrefix_Call {
	return &Location_ListByPrefix_Call{Call: _e.mock.On("ListByPrefix", prefix)}
}

func (_c *Location_ListByPrefix_Call) Run(run func(prefix string)) *Location_ListByPrefix_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Location_ListByPrefix_Call) Return(strings []string, err error) *Location_ListByPrefix_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *Location_ListByPrefix_Call) RunAndReturn(run func(prefix string) ([]string, error)) *Location_ListByPrefix_Call {
	_c.Call.Return(run)
	return _c
}

// ListByRegex provides a mock function for the type Location
func (_mock *Location) ListByRegex(regex *regexp.Regexp) ([]string, error) {
	ret := _mock.Called(regex)

	if len(ret) == 0 {
		panic("no return value specified for ListByRegex")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*regexp.Regexp) ([]string, error)); ok {
		return returnFunc(regex)
	}
	if returnFunc, ok := ret.Get(0).(func(*regexp.Regexp) []string); ok {
		r0 = returnFunc(regex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*regexp.Regexp) error); ok {
		r1 = returnFunc(regex)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Location_ListByRegex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListByRegex'
type Location_ListByRegex_Call struct {
	*mock.Call
}

// ListByRegex is a helper method to define mock.On call
//   - regex *regexp.Regexp
func (_e *Location_Expecter) ListByRegex(regex interface{}) *Location_ListByRegex_Call {
	return &Location_ListByRegex_Call{Call: _e.mock.On("ListByRegex", regex)}
}

func (_c *Location_ListByRegex_Call) Run(run func(regex *regexp.Regexp)) *Location_ListByRegex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *regexp.Regexp
		if args[0] != nil {
			arg0 = args[0].(*regexp.Regexp)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Location_ListByRegex_Call) Return(strings []string, err error) *Location_ListByRegex_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *Location_ListByRegex_Call) RunAndReturn(run func(regex *regexp.Regexp) ([]string, error)) *Location_ListByRegex_Call {
	_c.Call.Return(run)
	return _c
}

// NewFile provides a mock function for the type Location
func (_mock *Location) NewFile(relFilePath string, opts ...options.NewFileOption) (vfs.File, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(relFilePath, opts)
	} else {
		tmpRet = _mock.Called(relFilePath)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for NewFile")
	}

	var r0 vfs.File
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, ...options.NewFileOption) (vfs.File, error)); ok {
		return returnFunc(relFilePath, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(string, ...options.NewFileOption) vfs.File); ok {
		r0 = returnFunc(relFilePath, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(vfs.File)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, ...options.NewFileOption) error); ok {
		r1 = returnFunc(relFilePath, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Location_NewFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewFile'
type Location_NewFile_Call struct {
	*mock.Call
}

// NewFile is a helper method to define mock.On call
//   - relFilePath string
//   - opts ...options.NewFileOption
func (_e *Location_Expecter) NewFile(relFilePath interface{}, opts ...interface{}) *Location_NewFile_Call {
	return &Location_NewFile_Call{Call: _e.mock.On("NewFile",
		append([]interface{}{relFilePath}, opts...)...)}
}

func (_c *Location_NewFile_Call) Run(run func(relFilePath string, opts ...options.NewFileOption)) *Location_NewFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []options.NewFileOption
		var variadicArgs []options.NewFileOption
		if len(args) > 1 {
			variadicArgs = args[1].([]options.NewFileOption)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *Location_NewFile_Call) Return(file vfs.File, err error) *Location_NewFile_Call {
	_c.Call.Return(file, err)
	return _c
}

func (_c *Location_NewFile_Call) RunAndReturn(run func(relFilePath string, opts ...options.NewFileOption) (vfs.File, error)) *Location_NewFile_Call {
	_c.Call.Return(run)
	return _c
}

// NewLocation provides a mock function for the type Location
func (_mock *Location) NewLocation(relLocPath string) (vfs.Location, error) {
	ret := _mock.Called(relLocPath)

	if len(ret) == 0 {
		panic("no return value specified for NewLocation")
	}

	var r0 vfs.Location
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (vfs.Location, error)); ok {
		return returnFunc(relLocPath)
	}
	if returnFunc, ok := ret.Get(0).(func(string) vfs.Location); ok {
		r0 = returnFunc(relLocPath)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(vfs.Location)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(relLocPath)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Location_NewLocation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewLocation'
type Location_NewLocation_Call struct {
	*mock.Call
}

// NewLocation is a helper method to define mock.On call
//   - relLocPath string
func (_e *Location_Expecter) NewLocation(relLocPath interface{}) *Location_NewLocation_Call {
	return &Location_NewLocation_Call{Call: _e.mock.On("NewLocation", relLocPath)}
}

func (_c *Location_NewLocation_Call) Run(run func(relLocPath string)) *Location_NewLocation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Location_NewLocation_Call) Return(location vfs.Location, err error) *Location_NewLocation_Call {
	_c.Call.Return(location, err)
	return _c
}

func (_c *Location_NewLocation_Call) RunAndReturn(run func(relLocPath string) (vfs.Location, error)) *Location_NewLocation_Call {
	_c.Call.Return(run)
	return _c
}

// Path provides a mock function for the type Location
func (_mock *Location) Path() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Path")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// Location_Path_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Path'
type Location_Path_Call struct {
	*mock.Call
}

// Path is a helper method to define mock.On call
func (_e *Location_Expecter) Path() *Location_Path_Call {
	return &Location_Path_Call{Call: _e.mock.On("Path")}
}

func (_c *Location_Path_Call) Run(run func()) *Location_Path_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Location_Path_Call) Return(s string) *Location_Path_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *Location_Path_Call) RunAndReturn(run func() string) *Location_Path_Call {
	_c.Call.Return(run)
	return _c
}

// String provides a mock function for the type Location
func (_mock *Location) String() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for String")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// Location_String_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'String'
type Location_String_Call struct {
	*mock.Call
}

// String is a helper method to define mock.On call
func (_e *Location_Expecter) String() *Location_String_Call {
	return &Location_String_Call{Call: _e.mock.On("String")}
}

func (_c *Location_String_Call) Run(run func()) *Location_String_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Location_String_Call) Return(s string) *Location_String_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *Location_String_Call) RunAndReturn(run func() string) *Location_String_Call {
	_c.Call.Return(run)
	return _c
}

// URI provides a mock function for the type Location
func (_mock *Location) URI() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for URI")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// Location_URI_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'URI'
type Location_URI_Call struct {
	*mock.Call
}

// URI is a helper method to define mock.On call
func (_e *Location_Expecter) URI() *Location_URI_Call {
	return &Location_URI_Call{Call: _e.mock.On("URI")}
}

func (_c *Location_URI_Call) Run(run func()) *Location_URI_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Location_URI_Call) Return(s string) *Location_URI_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *Location_URI_Call) RunAndReturn(run func() string) *Location_URI_Call {
	_c.Call.Return(run)
	return _c
}

// Volume provides a mock function for the type Location
func (_mock *Location) Volume() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Volume")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// Location_Volume_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Volume'
type Location_Volume_Call struct {
	*mock.Call
}

// Volume is a helper method to define mock.On call
func (_e *Location_Expecter) Volume() *Location_Volume_Call {
	return &Location_Volume_Call{Call: _e.mock.On("Volume")}
}

func (_c *Location_Volume_Call) Run(run func()) *Location_Volume_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Location_Volume_Call) Return(s string) *Location_Volume_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *Location_Volume_Call) RunAndReturn(run func() string) *Location_Volume_Call {
	_c.Call.Return(run)
	return _c
}
