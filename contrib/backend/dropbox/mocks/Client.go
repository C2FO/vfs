// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"io"

	"github.com/dropbox/dropbox-sdk-go-unofficial/v6/dropbox/files"
	mock "github.com/stretchr/testify/mock"
)

// NewClient creates a new instance of Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *Client {
	mock := &Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

type Client_Expecter struct {
	mock *mock.Mock
}

func (_m *Client) EXPECT() *Client_Expecter {
	return &Client_Expecter{mock: &_m.Mock}
}

// CopyV2 provides a mock function for the type Client
func (_mock *Client) CopyV2(arg *files.RelocationArg) (*files.RelocationResult, error) {
	ret := _mock.Called(arg)

	if len(ret) == 0 {
		panic("no return value specified for CopyV2")
	}

	var r0 *files.RelocationResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*files.RelocationArg) (*files.RelocationResult, error)); ok {
		return returnFunc(arg)
	}
	if returnFunc, ok := ret.Get(0).(func(*files.RelocationArg) *files.RelocationResult); ok {
		r0 = returnFunc(arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*files.RelocationResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*files.RelocationArg) error); ok {
		r1 = returnFunc(arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_CopyV2_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyV2'
type Client_CopyV2_Call struct {
	*mock.Call
}

// CopyV2 is a helper method to define mock.On call
//   - arg *files.RelocationArg
func (_e *Client_Expecter) CopyV2(arg interface{}) *Client_CopyV2_Call {
	return &Client_CopyV2_Call{Call: _e.mock.On("CopyV2", arg)}
}

func (_c *Client_CopyV2_Call) Run(run func(arg *files.RelocationArg)) *Client_CopyV2_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *files.RelocationArg
		if args[0] != nil {
			arg0 = args[0].(*files.RelocationArg)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_CopyV2_Call) Return(relocationResult *files.RelocationResult, err error) *Client_CopyV2_Call {
	_c.Call.Return(relocationResult, err)
	return _c
}

func (_c *Client_CopyV2_Call) RunAndReturn(run func(arg *files.RelocationArg) (*files.RelocationResult, error)) *Client_CopyV2_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteV2 provides a mock function for the type Client
func (_mock *Client) DeleteV2(arg *files.DeleteArg) (*files.DeleteResult, error) {
	ret := _mock.Called(arg)

	if len(ret) == 0 {
		panic("no return value specified for DeleteV2")
	}

	var r0 *files.DeleteResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*files.DeleteArg) (*files.DeleteResult, error)); ok {
		return returnFunc(arg)
	}
	if returnFunc, ok := ret.Get(0).(func(*files.DeleteArg) *files.DeleteResult); ok {
		r0 = returnFunc(arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*files.DeleteResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*files.DeleteArg) error); ok {
		r1 = returnFunc(arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_DeleteV2_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteV2'
type Client_DeleteV2_Call struct {
	*mock.Call
}

// DeleteV2 is a helper method to define mock.On call
//   - arg *files.DeleteArg
func (_e *Client_Expecter) DeleteV2(arg interface{}) *Client_DeleteV2_Call {
	return &Client_DeleteV2_Call{Call: _e.mock.On("DeleteV2", arg)}
}

func (_c *Client_DeleteV2_Call) Run(run func(arg *files.DeleteArg)) *Client_DeleteV2_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *files.DeleteArg
		if args[0] != nil {
			arg0 = args[0].(*files.DeleteArg)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_DeleteV2_Call) Return(deleteResult *files.DeleteResult, err error) *Client_DeleteV2_Call {
	_c.Call.Return(deleteResult, err)
	return _c
}

func (_c *Client_DeleteV2_Call) RunAndReturn(run func(arg *files.DeleteArg) (*files.DeleteResult, error)) *Client_DeleteV2_Call {
	_c.Call.Return(run)
	return _c
}

// Download provides a mock function for the type Client
func (_mock *Client) Download(arg *files.DownloadArg) (*files.FileMetadata, io.ReadCloser, error) {
	ret := _mock.Called(arg)

	if len(ret) == 0 {
		panic("no return value specified for Download")
	}

	var r0 *files.FileMetadata
	var r1 io.ReadCloser
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(*files.DownloadArg) (*files.FileMetadata, io.ReadCloser, error)); ok {
		return returnFunc(arg)
	}
	if returnFunc, ok := ret.Get(0).(func(*files.DownloadArg) *files.FileMetadata); ok {
		r0 = returnFunc(arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*files.FileMetadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*files.DownloadArg) io.ReadCloser); ok {
		r1 = returnFunc(arg)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(io.ReadCloser)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(*files.DownloadArg) error); ok {
		r2 = returnFunc(arg)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Client_Download_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Download'
type Client_Download_Call struct {
	*mock.Call
}

// Download is a helper method to define mock.On call
//   - arg *files.DownloadArg
func (_e *Client_Expecter) Download(arg interface{}) *Client_Download_Call {
	return &Client_Download_Call{Call: _e.mock.On("Download", arg)}
}

func (_c *Client_Download_Call) Run(run func(arg *files.DownloadArg)) *Client_Download_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *files.DownloadArg
		if args[0] != nil {
			arg0 = args[0].(*files.DownloadArg)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_Download_Call) Return(fileMetadata *files.FileMetadata, readCloser io.ReadCloser, err error) *Client_Download_Call {
	_c.Call.Return(fileMetadata, readCloser, err)
	return _c
}

func (_c *Client_Download_Call) RunAndReturn(run func(arg *files.DownloadArg) (*files.FileMetadata, io.ReadCloser, error)) *Client_Download_Call {
	_c.Call.Return(run)
	return _c
}

// GetMetadata provides a mock function for the type Client
func (_mock *Client) GetMetadata(arg *files.GetMetadataArg) (files.IsMetadata, error) {
	ret := _mock.Called(arg)

	if len(ret) == 0 {
		panic("no return value specified for GetMetadata")
	}

	var r0 files.IsMetadata
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*files.GetMetadataArg) (files.IsMetadata, error)); ok {
		return returnFunc(arg)
	}
	if returnFunc, ok := ret.Get(0).(func(*files.GetMetadataArg) files.IsMetadata); ok {
		r0 = returnFunc(arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(files.IsMetadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*files.GetMetadataArg) error); ok {
		r1 = returnFunc(arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GetMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMetadata'
type Client_GetMetadata_Call struct {
	*mock.Call
}

// GetMetadata is a helper method to define mock.On call
//   - arg *files.GetMetadataArg
func (_e *Client_Expecter) GetMetadata(arg interface{}) *Client_GetMetadata_Call {
	return &Client_GetMetadata_Call{Call: _e.mock.On("GetMetadata", arg)}
}

func (_c *Client_GetMetadata_Call) Run(run func(arg *files.GetMetadataArg)) *Client_GetMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *files.GetMetadataArg
		if args[0] != nil {
			arg0 = args[0].(*files.GetMetadataArg)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_GetMetadata_Call) Return(isMetadata files.IsMetadata, err error) *Client_GetMetadata_Call {
	_c.Call.Return(isMetadata, err)
	return _c
}

func (_c *Client_GetMetadata_Call) RunAndReturn(run func(arg *files.GetMetadataArg) (files.IsMetadata, error)) *Client_GetMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// ListFolder provides a mock function for the type Client
func (_mock *Client) ListFolder(arg *files.ListFolderArg) (*files.ListFolderResult, error) {
	ret := _mock.Called(arg)

	if len(ret) == 0 {
		panic("no return value specified for ListFolder")
	}

	var r0 *files.ListFolderResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*files.ListFolderArg) (*files.ListFolderResult, error)); ok {
		return returnFunc(arg)
	}
	if returnFunc, ok := ret.Get(0).(func(*files.ListFolderArg) *files.ListFolderResult); ok {
		r0 = returnFunc(arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*files.ListFolderResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*files.ListFolderArg) error); ok {
		r1 = returnFunc(arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_ListFolder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListFolder'
type Client_ListFolder_Call struct {
	*mock.Call
}

// ListFolder is a helper method to define mock.On call
//   - arg *files.ListFolderArg
func (_e *Client_Expecter) ListFolder(arg interface{}) *Client_ListFolder_Call {
	return &Client_ListFolder_Call{Call: _e.mock.On("ListFolder", arg)}
}

func (_c *Client_ListFolder_Call) Run(run func(arg *files.ListFolderArg)) *Client_ListFolder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *files.ListFolderArg
		if args[0] != nil {
			arg0 = args[0].(*files.ListFolderArg)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_ListFolder_Call) Return(listFolderResult *files.ListFolderResult, err error) *Client_ListFolder_Call {
	_c.Call.Return(listFolderResult, err)
	return _c
}

func (_c *Client_ListFolder_Call) RunAndReturn(run func(arg *files.ListFolderArg) (*files.ListFolderResult, error)) *Client_ListFolder_Call {
	_c.Call.Return(run)
	return _c
}

// ListFolderContinue provides a mock function for the type Client
func (_mock *Client) ListFolderContinue(arg *files.ListFolderContinueArg) (*files.ListFolderResult, error) {
	ret := _mock.Called(arg)

	if len(ret) == 0 {
		panic("no return value specified for ListFolderContinue")
	}

	var r0 *files.ListFolderResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*files.ListFolderContinueArg) (*files.ListFolderResult, error)); ok {
		return returnFunc(arg)
	}
	if returnFunc, ok := ret.Get(0).(func(*files.ListFolderContinueArg) *files.ListFolderResult); ok {
		r0 = returnFunc(arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*files.ListFolderResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*files.ListFolderContinueArg) error); ok {
		r1 = returnFunc(arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_ListFolderContinue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListFolderContinue'
type Client_ListFolderContinue_Call struct {
	*mock.Call
}

// ListFolderContinue is a helper method to define mock.On call
//   - arg *files.ListFolderContinueArg
func (_e *Client_Expecter) ListFolderContinue(arg interface{}) *Client_ListFolderContinue_Call {
	return &Client_ListFolderContinue_Call{Call: _e.mock.On("ListFolderContinue", arg)}
}

func (_c *Client_ListFolderContinue_Call) Run(run func(arg *files.ListFolderContinueArg)) *Client_ListFolderContinue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *files.ListFolderContinueArg
		if args[0] != nil {
			arg0 = args[0].(*files.ListFolderContinueArg)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_ListFolderContinue_Call) Return(listFolderResult *files.ListFolderResult, err error) *Client_ListFolderContinue_Call {
	_c.Call.Return(listFolderResult, err)
	return _c
}

func (_c *Client_ListFolderContinue_Call) RunAndReturn(run func(arg *files.ListFolderContinueArg) (*files.ListFolderResult, error)) *Client_ListFolderContinue_Call {
	_c.Call.Return(run)
	return _c
}

// MoveV2 provides a mock function for the type Client
func (_mock *Client) MoveV2(arg *files.RelocationArg) (*files.RelocationResult, error) {
	ret := _mock.Called(arg)

	if len(ret) == 0 {
		panic("no return value specified for MoveV2")
	}

	var r0 *files.RelocationResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*files.RelocationArg) (*files.RelocationResult, error)); ok {
		return returnFunc(arg)
	}
	if returnFunc, ok := ret.Get(0).(func(*files.RelocationArg) *files.RelocationResult); ok {
		r0 = returnFunc(arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*files.RelocationResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*files.RelocationArg) error); ok {
		r1 = returnFunc(arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_MoveV2_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MoveV2'
type Client_MoveV2_Call struct {
	*mock.Call
}

// MoveV2 is a helper method to define mock.On call
//   - arg *files.RelocationArg
func (_e *Client_Expecter) MoveV2(arg interface{}) *Client_MoveV2_Call {
	return &Client_MoveV2_Call{Call: _e.mock.On("MoveV2", arg)}
}

func (_c *Client_MoveV2_Call) Run(run func(arg *files.RelocationArg)) *Client_MoveV2_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *files.RelocationArg
		if args[0] != nil {
			arg0 = args[0].(*files.RelocationArg)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_MoveV2_Call) Return(relocationResult *files.RelocationResult, err error) *Client_MoveV2_Call {
	_c.Call.Return(relocationResult, err)
	return _c
}

func (_c *Client_MoveV2_Call) RunAndReturn(run func(arg *files.RelocationArg) (*files.RelocationResult, error)) *Client_MoveV2_Call {
	_c.Call.Return(run)
	return _c
}

// Upload provides a mock function for the type Client
func (_mock *Client) Upload(arg *files.UploadArg, content io.Reader) (*files.FileMetadata, error) {
	ret := _mock.Called(arg, content)

	if len(ret) == 0 {
		panic("no return value specified for Upload")
	}

	var r0 *files.FileMetadata
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*files.UploadArg, io.Reader) (*files.FileMetadata, error)); ok {
		return returnFunc(arg, content)
	}
	if returnFunc, ok := ret.Get(0).(func(*files.UploadArg, io.Reader) *files.FileMetadata); ok {
		r0 = returnFunc(arg, content)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*files.FileMetadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*files.UploadArg, io.Reader) error); ok {
		r1 = returnFunc(arg, content)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_Upload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Upload'
type Client_Upload_Call struct {
	*mock.Call
}

// Upload is a helper method to define mock.On call
//   - arg *files.UploadArg
//   - content io.Reader
func (_e *Client_Expecter) Upload(arg interface{}, content interface{}) *Client_Upload_Call {
	return &Client_Upload_Call{Call: _e.mock.On("Upload", arg, content)}
}

func (_c *Client_Upload_Call) Run(run func(arg *files.UploadArg, content io.Reader)) *Client_Upload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *files.UploadArg
		if args[0] != nil {
			arg0 = args[0].(*files.UploadArg)
		}
		var arg1 io.Reader
		if args[1] != nil {
			arg1 = args[1].(io.Reader)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_Upload_Call) Return(fileMetadata *files.FileMetadata, err error) *Client_Upload_Call {
	_c.Call.Return(fileMetadata, err)
	return _c
}

func (_c *Client_Upload_Call) RunAndReturn(run func(arg *files.UploadArg, content io.Reader) (*files.FileMetadata, error)) *Client_Upload_Call {
	_c.Call.Return(run)
	return _c
}

// UploadSessionAppendV2 provides a mock function for the type Client
func (_mock *Client) UploadSessionAppendV2(arg *files.UploadSessionAppendArg, content io.Reader) error {
	ret := _mock.Called(arg, content)

	if len(ret) == 0 {
		panic("no return value specified for UploadSessionAppendV2")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*files.UploadSessionAppendArg, io.Reader) error); ok {
		r0 = returnFunc(arg, content)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_UploadSessionAppendV2_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UploadSessionAppendV2'
type Client_UploadSessionAppendV2_Call struct {
	*mock.Call
}

// UploadSessionAppendV2 is a helper method to define mock.On call
//   - arg *files.UploadSessionAppendArg
//   - content io.Reader
func (_e *Client_Expecter) UploadSessionAppendV2(arg interface{}, content interface{}) *Client_UploadSessionAppendV2_Call {
	return &Client_UploadSessionAppendV2_Call{Call: _e.mock.On("UploadSessionAppendV2", arg, content)}
}

func (_c *Client_UploadSessionAppendV2_Call) Run(run func(arg *files.UploadSessionAppendArg, content io.Reader)) *Client_UploadSessionAppendV2_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *files.UploadSessionAppendArg
		if args[0] != nil {
			arg0 = args[0].(*files.UploadSessionAppendArg)
		}
		var arg1 io.Reader
		if args[1] != nil {
			arg1 = args[1].(io.Reader)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_UploadSessionAppendV2_Call) Return(err error) *Client_UploadSessionAppendV2_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_UploadSessionAppendV2_Call) RunAndReturn(run func(arg *files.UploadSessionAppendArg, content io.Reader) error) *Client_UploadSessionAppendV2_Call {
	_c.Call.Return(run)
	return _c
}

// UploadSessionFinish provides a mock function for the type Client
func (_mock *Client) UploadSessionFinish(arg *files.UploadSessionFinishArg, content io.Reader) (*files.FileMetadata, error) {
	ret := _mock.Called(arg, content)

	if len(ret) == 0 {
		panic("no return value specified for UploadSessionFinish")
	}

	var r0 *files.FileMetadata
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*files.UploadSessionFinishArg, io.Reader) (*files.FileMetadata, error)); ok {
		return returnFunc(arg, content)
	}
	if returnFunc, ok := ret.Get(0).(func(*files.UploadSessionFinishArg, io.Reader) *files.FileMetadata); ok {
		r0 = returnFunc(arg, content)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*files.FileMetadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*files.UploadSessionFinishArg, io.Reader) error); ok {
		r1 = returnFunc(arg, content)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_UploadSessionFinish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UploadSessionFinish'
type Client_UploadSessionFinish_Call struct {
	*mock.Call
}

// UploadSessionFinish is a helper method to define mock.On call
//   - arg *files.UploadSessionFinishArg
//   - content io.Reader
func (_e *Client_Expecter) UploadSessionFinish(arg interface{}, content interface{}) *Client_UploadSessionFinish_Call {
	return &Client_UploadSessionFinish_Call{Call: _e.mock.On("UploadSessionFinish", arg, content)}
}

func (_c *Client_UploadSessionFinish_Call) Run(run func(arg *files.UploadSessionFinishArg, content io.Reader)) *Client_UploadSessionFinish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *files.UploadSessionFinishArg
		if args[0] != nil {
			arg0 = args[0].(*files.UploadSessionFinishArg)
		}
		var arg1 io.Reader
		if args[1] != nil {
			arg1 = args[1].(io.Reader)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_UploadSessionFinish_Call) Return(fileMetadata *files.FileMetadata, err error) *Client_UploadSessionFinish_Call {
	_c.Call.Return(fileMetadata, err)
	return _c
}

func (_c *Client_UploadSessionFinish_Call) RunAndReturn(run func(arg *files.UploadSessionFinishArg, content io.Reader) (*files.FileMetadata, error)) *Client_UploadSessionFinish_Call {
	_c.Call.Return(run)
	return _c
}

// UploadSessionStart provides a mock function for the type Client
func (_mock *Client) UploadSessionStart(arg *files.UploadSessionStartArg, content io.Reader) (*files.UploadSessionStartResult, error) {
	ret := _mock.Called(arg, content)

	if len(ret) == 0 {
		panic("no return value specified for UploadSessionStart")
	}

	var r0 *files.UploadSessionStartResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*files.UploadSessionStartArg, io.Reader) (*files.UploadSessionStartResult, error)); ok {
		return returnFunc(arg, content)
	}
	if returnFunc, ok := ret.Get(0).(func(*files.UploadSessionStartArg, io.Reader) *files.UploadSessionStartResult); ok {
		r0 = returnFunc(arg, content)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*files.UploadSessionStartResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*files.UploadSessionStartArg, io.Reader) error); ok {
		r1 = returnFunc(arg, content)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_UploadSessionStart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UploadSessionStart'
type Client_UploadSessionStart_Call struct {
	*mock.Call
}

// UploadSessionStart is a helper method to define mock.On call
//   - arg *files.UploadSessionStartArg
//   - content io.Reader
func (_e *Client_Expecter) UploadSessionStart(arg interface{}, content interface{}) *Client_UploadSessionStart_Call {
	return &Client_UploadSessionStart_Call{Call: _e.mock.On("UploadSessionStart", arg, content)}
}

func (_c *Client_UploadSessionStart_Call) Run(run func(arg *files.UploadSessionStartArg, content io.Reader)) *Client_UploadSessionStart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *files.UploadSessionStartArg
		if args[0] != nil {
			arg0 = args[0].(*files.UploadSessionStartArg)
		}
		var arg1 io.Reader
		if args[1] != nil {
			arg1 = args[1].(io.Reader)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_UploadSessionStart_Call) Return(uploadSessionStartResult *files.UploadSessionStartResult, err error) *Client_UploadSessionStart_Call {
	_c.Call.Return(uploadSessionStartResult, err)
	return _c
}

func (_c *Client_UploadSessionStart_Call) RunAndReturn(run func(arg *files.UploadSessionStartArg, content io.Reader) (*files.UploadSessionStartResult, error)) *Client_UploadSessionStart_Call {
	_c.Call.Return(run)
	return _c
}
